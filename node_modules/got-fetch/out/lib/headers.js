"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GotHeaders = void 0;
class GotHeaders {
    constructor(headers, guard = 'none') {
        const init = headers ? Object.entries(headers).map(([name, values]) => {
            if (typeof values === 'string') {
                return [name.toLowerCase(), [values]];
            }
            else if (Array.isArray(values)) {
                return [name.toLowerCase(), values];
            }
            else {
                return [name.toLowerCase(), []];
            }
        }) : [];
        this.guard = guard;
        this.headers = new Map(init);
    }
    checkGuard() {
        if (this.guard === 'immutable') {
            throw new TypeError('Header guard set to `immutable`');
        }
    }
    append(name, value) {
        this.checkGuard();
        const key = name.toLowerCase();
        this.headers.set(key, (this.headers.get(key) || []).concat([value]));
    }
    delete(name) {
        this.checkGuard();
        this.headers.delete(name.toLowerCase());
    }
    get(name) {
        const values = this.headers.get(name.toLowerCase());
        return values ? values.join(', ') : null;
    }
    has(name) {
        return this.headers.has(name.toLowerCase());
    }
    set(name, value) {
        this.checkGuard();
        this.headers.set(name.toLowerCase(), [value]);
    }
    forEach(callbackfn, thisArg) {
        this.headers.forEach((val, name) => {
            callbackfn.call(thisArg, this.get(name), name, this);
        });
    }
    *entries() {
        for (const key of this.headers.keys()) {
            yield [key, this.get(key)];
        }
    }
    keys() {
        return this.headers.keys();
    }
    *values() {
        for (const key of this.headers.keys()) {
            yield this.get(key);
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
}
exports.GotHeaders = GotHeaders;
//# sourceMappingURL=headers.js.map