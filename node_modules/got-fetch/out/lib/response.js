"use strict";
/**
 * Spec:
 * https://fetch.spec.whatwg.org/#response-class
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GotFetchResponse = void 0;
const util_1 = require("util");
const headers_1 = require("./headers");
class GotFetchResponse {
    constructor(body, init) {
        if (init && typeof init.status === 'number' && (init.status < 200 || init.status > 599)) {
            throw new RangeError((0, util_1.format)('init.status is out of range: %s', init.status));
        }
        this.body = body;
        this.type = init && init.type || 'basic';
        this.headers = new headers_1.GotHeaders(init ? init.headers : undefined, 'immutable');
        this.status = init && init.status || 0;
        this.statusText = String(init && init.statusText || '');
        this.url = init && init.url || '';
        this.redirected = init && init.redirected || false;
    }
    get bodyUsed() {
        // if it's a string or a Buffer then we've already read the full body in memory
        // and the stream this body came from is "disturbed"
        return typeof this.body === 'string' || Buffer.isBuffer(this.body);
    }
    get ok() {
        return this.status >= 200 && this.status <= 299;
    }
    get trailer() {
        return Promise.reject(new TypeError('`trailer` promise not supported'));
    }
    arrayBuffer() {
        throw new Error("`arrayBuffer` not implemented");
    }
    blob() {
        throw new Error('`blob` not implemented');
    }
    formData() {
        return this.text().then(body => new URLSearchParams(body));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    json() {
        return this.text().then(JSON.parse);
    }
    text() {
        if (this.body === null) {
            return Promise.resolve('');
        }
        if (typeof this.body === 'string') {
            return Promise.resolve(this.body);
        }
        else if (Buffer.isBuffer(this.body)) {
            return Promise.resolve(this.body.toString('utf8'));
        }
        else {
            return Promise.reject(new TypeError('Unsupported body type'));
        }
    }
    clone() {
        throw new Error('clone not implemented');
    }
    static error() {
        return new GotFetchResponse(null, { type: 'error' });
    }
}
exports.GotFetchResponse = GotFetchResponse;
//# sourceMappingURL=response.js.map