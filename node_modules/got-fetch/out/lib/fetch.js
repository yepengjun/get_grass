"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFetch = void 0;
const tslib_1 = require("tslib");
const stream_1 = require("stream");
const url_1 = require("url");
const util_1 = require("util");
const response_1 = require("./response");
function createFetch(got) {
    const globalCache = new Map();
    return (input, opts) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        var _a;
        const url = new url_1.URL(typeof input === 'string' ? input : input.url);
        const request = typeof input === 'object' ? input : opts || {};
        if (request.mode === 'no-cors' || request.mode === 'same-origin' || request.mode === 'navigate') {
            throw new TypeError((0, util_1.format)('request.mode not supported: %s', request.mode));
        }
        if (request.cache === 'only-if-cached') {
            throw new TypeError((0, util_1.format)('request.cache not supported: %s', request.cache));
        }
        if (request.redirect === 'error' || request.redirect === 'manual') {
            throw new TypeError((0, util_1.format)('request.redirect not supported: %s', request.redirect));
        }
        // naive check to make sure headers are a plain object
        if (request.headers && typeof request.headers !== 'object') {
            throw new TypeError((0, util_1.format)('request.headers must be plain object: %j', request.headers));
        }
        // got does not merge base searchParams with the url's searchParams
        // but it does merge searchParams options
        // so we clone the url's searchParams
        // we also clear the url's search to work around this bug
        // https://github.com/sindresorhus/got/issues/1188
        const searchParams = new url_1.URLSearchParams(url.searchParams);
        url.search = '';
        const gotOpts = {
            // url needs to be stringified to support UNIX domain sockets, and
            // For more info see https://github.com/alexghr/got-fetch/pull/8
            url: url.toString(),
            searchParams,
            followRedirect: true,
            throwHttpErrors: false,
            method: request.method || 'get',
            isStream: false,
            resolveBodyOnly: false,
            // we'll do our own response parsing in `GotFetchResponse`
            responseType: undefined
        };
        const { body, headers: bodyHeaders = {} } = serializeBody(request.body);
        // only set the `body` key on the options if a body is sent
        // otherwise got crashes
        if (body) {
            gotOpts.body = body;
        }
        const headers = Object.assign({}, bodyHeaders);
        if (request.headers) {
            if (Array.isArray(request.headers)) {
                request.headers.forEach(([header, value]) => {
                    headers[header.toLowerCase()] = value;
                });
            }
            else if (typeof ((_a = request.headers) === null || _a === void 0 ? void 0 : _a.forEach) === "function") {
                request.headers.forEach((value, header) => {
                    headers[header.toLowerCase()] = value;
                });
            }
            else {
                Object.keys(request.headers).forEach((header) => {
                    headers[header.toLowerCase()] = request.headers[header];
                });
            }
        }
        gotOpts.headers = headers;
        // there's a bug in got where it crashes if we send both a body and cache
        // https://github.com/sindresorhus/got/issues/1021
        if ((typeof request.cache === 'undefined' || request.cache === 'default') && !gotOpts.body) {
            gotOpts.cache = globalCache;
        }
        const response = got(gotOpts);
        if (request.signal) {
            const abortHandler = () => response.cancel();
            request.signal.addEventListener('abort', abortHandler);
            response.then(() => request.signal.removeEventListener('abort', abortHandler));
        }
        return response.then(r => {
            return new response_1.GotFetchResponse(r.body, {
                headers: r.headers,
                redirected: r.redirectUrls && r.redirectUrls.length > 0,
                status: r.statusCode,
                statusText: r.statusMessage,
                type: "default",
                // according to spec this should be the final URL, after all redirects
                url: r.redirectUrls.length > 0
                    // using Array.prototype.at would've been nice but it's not
                    // supported by anything below Node 16.8
                    ? r.redirectUrls[r.redirectUrls.length - 1]
                    : url.href,
            });
        });
    });
}
exports.createFetch = createFetch;
function serializeBody(body) {
    if (!body) {
        return {};
    }
    else if (body instanceof url_1.URLSearchParams) {
        const serialized = body.toString();
        return {
            body: serialized,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
                'Content-Length': String(Buffer.byteLength(serialized, 'utf8'))
            }
        };
    }
    else if (typeof body === 'string') {
        return {
            body,
            headers: {
                'Content-Type': 'text/plain; charset=utf-8',
                'Content-Length': String(Buffer.byteLength(body, 'utf8')),
            }
        };
    }
    else if (Buffer.isBuffer(body) || (body instanceof stream_1.Readable)) {
        return {
            body,
            headers: {
                'Content-Type': 'application/octet-stream'
            }
        };
    }
    else {
        throw new TypeError('Unsupported request body');
    }
}
//# sourceMappingURL=fetch.js.map